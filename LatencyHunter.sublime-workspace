{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"file": "sender.c",
			"settings":
			{
				"buffer_size": 6776,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*\n** Copyright 2005-2016  Solarflare Communications Inc.\n**                      7505 Irvine Center Drive, Irvine, CA 92618, USA\n** Copyright 2002-2005  Level 5 Networks Inc.\n**\n** This program is free software; you can redistribute it and/or modify it\n** under the terms of version 2 of the GNU General Public License as\n** published by the Free Software Foundation.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n*/\n\n/**************************************************************************\\\n*//*! \\file\n** <L5_PRIVATE L5_SOURCE>\n** \\author  kjm\n**  \\brief  Example for TX timestamping sockets API\n**   \\date  2014/04/03\n**    \\cop  (c) Level 5 Networks Limited.\n** </L5_PRIVATE>\n*//*\n\\**************************************************************************/\n  \n\n/* Example application to demonstrate use of the timestamping API\n *\n * This application will echo packets, and display their TX timestamps.\n * With multiple different options for types of timestamp; including\n * hardware timestamps.\n *\n * Example:\n * (host1)$ EF_TX_TIMESTAMPING=1 onload tx_timestamping --proto tcp \n * (host2)$ echo payload | nc host1 9000\n * \n * (If not using onload, on most kernels, no TCP timestamp will be seen)\n */\n\n#include <unistd.h> \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n\n#include <netdb.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n\n#include \"onload/extensions.h\"\n\n/* Use the kernel definitions if possible -\n * But if not, use our own local definitions, and Onload will allow it.\n * - Though you still need a reasonably recent kernel to get hardware\n *   timestamping.  Software timestamps can go back several more versions.\n */\n#ifndef NO_KERNEL_TS_INCLUDE\n  #include <linux/net_tstamp.h>\n  #include <linux/sockios.h>\n#else\n  #include <time.h>\n  struct hwtstamp_config {\n      int flags;           /* no flags defined right now, must be zero */\n      int tx_type;         /* HWTSTAMP_TX_* */\n      int rx_filter;       /* HWTSTAMP_FILTER_* */\n  };\n  enum {\n        SOF_TIMESTAMPING_TX_HARDWARE = (1<<0),\n        SOF_TIMESTAMPING_TX_SOFTWARE = (1<<1),\n        SOF_TIMESTAMPING_RX_HARDWARE = (1<<2),\n        SOF_TIMESTAMPING_RX_SOFTWARE = (1<<3),\n        SOF_TIMESTAMPING_SOFTWARE = (1<<4),\n        SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),\n        SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),\n        SOF_TIMESTAMPING_MASK =\n        (SOF_TIMESTAMPING_RAW_HARDWARE - 1) |\n        SOF_TIMESTAMPING_RAW_HARDWARE\n  };\n#endif\n\n/* These are defined in socket.h, but older versions might not have all 3 */\n#ifndef SO_TIMESTAMP\n  #define SO_TIMESTAMP            29\n#endif\n#ifndef SO_TIMESTAMPNS\n  #define SO_TIMESTAMPNS          35\n#endif\n#ifndef SO_TIMESTAMPING\n  #define SO_TIMESTAMPING         37\n#endif\n\n/* Assert-like macros */\n#define TEST(x)                                                 \\\n  do {                                                          \\\n    if( ! (x) ) {                                               \\\n      fprintf(stderr, \"ERROR: '%s' failed\\n\", #x);              \\\n      fprintf(stderr, \"ERROR: at %s:%d\\n\", __FILE__, __LINE__); \\\n      exit(1);                                                  \\\n    }                                                           \\\n  } while( 0 )\n\n#define TRY(x)                                                          \\\n  do {                                                                  \\\n    int __rc = (x);                                                     \\\n      if( __rc < 0 ) {                                                  \\\n        fprintf(stderr, \"ERROR: TRY(%s) failed\\n\", #x);                 \\\n        fprintf(stderr, \"ERROR: at %s:%d\\n\", __FILE__, __LINE__);       \\\n        fprintf(stderr, \"ERROR: rc=%d errno=%d (%s)\\n\",                 \\\n                __rc, errno, strerror(errno));                          \\\n        exit(1);                                                        \\\n      }                                                                 \\\n  } while( 0 )\n\nstruct configuration {\n  int            cfg_protocol;  /* protocol: udp or tcp */\n  char const*    cfg_host;      /* listen address */\n  char const*    cfg_mcast;     /* e.g. 239.10.10.10 - sets IP_ADD_MULTICAST */\n  char const*    cfg_ioctl;     /* e.g. eth6  - calls the ts enable ioctl */\n  unsigned short cfg_port;      /* listen port */\n  unsigned int   cfg_max_packets; /* Stop after this many (0=forever) */\n};\n\n/* Commandline options, configuration etc. */\n\nvoid print_help(void) \n{\n  printf(\"Usage:\\n\"\n         \"\\t--proto\\t<udp|tcp>\\tProtocol.  Default: UDP\\n\"\n         \"\\t--host\\t<hostname>\\tHost to listen on / connect to.  \"\n           \"Default: Localhost\\n\"\n         \"\\t--port\\t<hostname>\\tHost to listen on / connect to.  \"\n           \"Default: Localhost\\n\"\n         \"\\t--ioctl\\t<ethX>\\tDevice to send timestamping enable ioctl.  \"\n           \"Default: None\\n\"\n         \"\\t--max\\t<num>\\tStop after n packets.  Default: Run forever\\n\"\n         \"\\t--mcast\\t<group>\\tSubscribe to multicast group.\\n\"\n        );\n  exit(-1);\n}\n\n#define MATCHES(_x,_y) ( strncasecmp((_x),(_y),strlen((_x)))==0 )\n\nstatic int get_protocol(char const* proto)\n{\n  if (MATCHES( \"udp\", proto )) return IPPROTO_UDP;\n  if (MATCHES( \"tcp\", proto )) return IPPROTO_TCP;\n\n  printf(\"Could not understand requested protocol %s\\n\", proto);\n  print_help();\n  return -1;\n}\n#undef MATCHES\n\nstatic void parse_options( int argc, char** argv, struct configuration* cfg )\n{\n  int option_index = 0;\n  int opt;\n  static struct option long_options[] = {\n    { \"proto\", required_argument, 0, 't' },\n    { \"host\", required_argument, 0, 'l' },\n    { \"ioctl\", required_argument, 0, 'i' },\n    { \"port\", required_argument, 0, 'p' },\n    { \"mcast\", required_argument, 0, 'c' },\n    { \"max\", required_argument, 0, 'n' },\n    { \"help\", no_argument, 0, 'h' },\n    { 0, no_argument, 0, 0 }\n  };\n  char const* optstring = \"tlipcnh\";\n\n  /* Defaults */\n  bzero(cfg, sizeof(struct configuration));\n  cfg->cfg_protocol = IPPROTO_UDP;\n  cfg->cfg_port = 9000;\n\n  opt = getopt_long(argc, argv, optstring, long_options, &option_index);\n  while( opt != -1 ) {\n    switch( opt ) {\n      case 't':\n        cfg->cfg_protocol = get_protocol(optarg);\n        break;\n      case 'l':\n        cfg->cfg_host = optarg;\n        break;\n      case 'i':\n        cfg->cfg_ioctl = optarg;\n        break;\n      case 'p':\n        cfg->cfg_port = atoi(optarg);\n        break;\n      case 'c':\n        cfg->cfg_mcast = optarg;\n        break;\n      case 'n':\n        cfg->cfg_max_packets = atoi(optarg);\n        break;\n      case 'h':\n      default:\n        print_help();\n        break;\n    }\n    opt = getopt_long(argc, argv, optstring, long_options, &option_index);\n  }\n}\n\n\n/* Connection */\nstatic void make_address(char const* host, unsigned short port, struct sockaddr_in* host_address)\n{\n  struct hostent *hPtr;\n\n  bzero(host_address, sizeof(struct sockaddr_in));\n\n  host_address->sin_family = AF_INET;\n  host_address->sin_port = htons(port);\n\n  if (host != NULL) {\n    hPtr = (struct hostent *) gethostbyname(host);\n    TEST( hPtr != NULL );\n\n    memcpy((char *)&host_address->sin_addr, hPtr->h_addr, hPtr->h_length);\n  } else {\n    host_address->sin_addr.s_addr=INADDR_ANY;\n  }\n}\n\n/* Option: --mcast group_ip_address */\nstatic void do_mcast(struct configuration* cfg, int sock)\n{\n  struct ip_mreq req;\n\n  if (cfg->cfg_mcast == NULL)\n    return;\n\n  bzero(&req, sizeof(req));\n  TRY(inet_aton(cfg->cfg_mcast, &req.imr_multiaddr));\n\n  req.imr_interface.s_addr = INADDR_ANY;\n  TRY(setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &req, sizeof(req)));\n}\n\n/* This requires a bit of explanation.\n * Typically, you have to enable hardware timestamping on an interface.\n * Any application can do it, and then it's available to everyone.\n * The easiest way to do this, is just to run sfptpd.\n *\n * But in case you need to do it manually; here is the code, but\n * that's only supported on reasonably recent versions\n *\n * Option: --ioctl ethX\n *\n * NOTE:\n * Usage of the ioctl call is discouraged. A better method, if using\n * hardware timestamping, would be to use sfptpd as it will effectively\n * make the ioctl call for you.\n *\n */\nstatic void do_ioctl(struct configuration* cfg, int sock)\n{\n#ifdef SIOCSHWTSTAMP\n  struct ifreq ifr;\n  struct hwtstamp_config hwc;\n  int ok;\n#endif\n\n  if(cfg->cfg_ioctl == NULL)\n    return;\n\n#ifdef SIOCSHWTSTAMP\n  bzero(&ifr, sizeof(ifr));\n  snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s\", cfg->cfg_ioctl);\n\n  hwc.flags = 0;\n  hwc.tx_type = HWTSTAMP_TX_ON;\n  hwc.rx_filter = 0;\n\n  ifr.ifr_data = (char*)&hwc;\n  \n  /* If using a TCP socket, we need to create a UDP one for the ioctl\n   * call.  This is fine as the setting is global for that\n   * interface \n   */\n  if ( cfg->cfg_protocol == IPPROTO_TCP ) {\n    sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    TEST(sock != -1);\n  }\n\n  ok = ioctl(sock, SIOCSHWTSTAMP, &ifr);\n  if ( ok < 0 ) {\n    printf(\"Setting SIOCSHWTSTAMP ioctl failed %d (%d - %s)\\n\", \n           ok, errno, strerror(errno));\n  } else {\n    printf(\"Accepted SIOCHWTSTAMP ioctl.\\n\");\n  }\n\n  if ( cfg->cfg_protocol == IPPROTO_TCP )\n    close(sock);\n\n  return;\n#else\n  (void) sock;\n  printf(\"SIOCHWTSTAMP ioctl not supported, ignoring --ioctl\\n\"\n         \"HW timestamps will be unavailable unless sfptpd is running\\n\");\n  return; \n#endif\n}\n\n/* This routine selects the correct socket option to enable timestamping.\n */\nstatic void do_ts_sockopt(struct configuration* cfg, int sock)\n{\n  int enable = 1;\n  int ok = 0;\n\n  printf(\"Selecting hardware timestamping mode.\\n\");\n  enable = SOF_TIMESTAMPING_TX_HARDWARE | SOF_TIMESTAMPING_SYS_HARDWARE |\n    SOF_TIMESTAMPING_RAW_HARDWARE;\n  if (cfg->cfg_protocol == IPPROTO_TCP)\n    enable |= ONLOAD_SOF_TIMESTAMPING_STREAM;\n  ok = setsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &enable, sizeof(int));\n  if (ok < 0) {\n    printf(\"Timestamp socket option failed.  %d (%d - %s)\\n\",\n            ok, errno, strerror(errno));\n    exit(ok);\n  }\n}\n\n/* Option: --proto udp (default), also --port nnn (default 9000) */\nstatic int add_udp(struct configuration* cfg)\n{\n  int s;\n  struct sockaddr_in host_address;\n\n  make_address(cfg->cfg_host, cfg->cfg_port, &host_address);\n\n  s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  TEST(s >= 0);\n\n  TRY(bind(s, (struct sockaddr*)&host_address, sizeof(host_address)) );\n\n  printf(\"UDP socket created, listening on port %d\\n\", cfg->cfg_port);\n\n  return s;\n}\n\n/* Option: --proto: tcp, also --port nnn (default 9000) */\nstatic int add_tcp(struct configuration* cfg)\n{\n  int s;\n\n  struct sockaddr_in host_address;\n  socklen_t clilen;\n  struct sockaddr_in cli_addr;\n  clilen = sizeof(cli_addr);\n  int connected_fd;\n\n  make_address(cfg->cfg_host, cfg->cfg_port, &host_address);\n  s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );\n  TEST(s >= 0);\n  TRY( bind(s, (struct sockaddr*)&host_address, sizeof(host_address)) );\n  TRY( listen( s, -1 ) );\n\n  printf( \"TCP listening on port %d\\n \", cfg->cfg_port );\n\n  connected_fd = accept(s, (struct sockaddr *) &cli_addr, &clilen);\n  TEST(connected_fd >= 0);\n  close(s);\n\n  printf(\"TCP connection accepted\\n\");\n  return connected_fd;\n}\n\nstatic int add_socket(struct configuration* cfg)\n{\n  switch(cfg->cfg_protocol) {\n  case IPPROTO_UDP:\n    return add_udp(cfg);\n  case IPPROTO_TCP:\n    return add_tcp(cfg);\n  default:\n    printf(\"Unsupported protocol %d\\n\", cfg->cfg_protocol);\n    exit(-1);\n  }\n}\n\n\n/* Processing */\n#define TIME_FMT \"%\" PRIu64 \".%.9\" PRIu64 \" \"\nstatic void print_time(char *s, struct timespec* ts)\n{\n   printf(\"%s timestamp \" TIME_FMT \"\\n\", s, \n          (uint64_t)ts->tv_sec, (uint64_t)ts->tv_nsec);\n}\n\n\n/* Given a packet, extract the timestamp(s) */\nstatic void handle_time(struct msghdr* msg)\n{\n  struct onload_scm_timestamping_stream* tcp_tx_stamps;\n  struct timespec* udp_tx_stamp;\n  struct cmsghdr* cmsg;\n\n  for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n    if (cmsg->cmsg_level != SOL_SOCKET)\n      continue;\n    switch(cmsg->cmsg_type) {\n    case ONLOAD_SCM_TIMESTAMPING_STREAM:\n      tcp_tx_stamps = (struct onload_scm_timestamping_stream*)CMSG_DATA(cmsg);\n      printf(\"Timestamp for %d bytes:\\n\", (int)tcp_tx_stamps->len);\n      print_time(\"First sent\", &tcp_tx_stamps->first_sent);\n      print_time(\"Last sent\", &tcp_tx_stamps->last_sent);\n      break;\n    case SO_TIMESTAMPING:\n      udp_tx_stamp = (struct timespec*) CMSG_DATA(cmsg);\n      print_time(\"System\", &(udp_tx_stamp[0]));\n      print_time(\"Transformed\", &(udp_tx_stamp[1]));\n      print_time(\"Raw\", &(udp_tx_stamp[2]));\n      break;\n    default:\n      /* Ignore other cmsg options */\n      break;\n    }\n  }\n}\n\n/* Receive a packet, and print out the timestamps from it */\nvoid do_echo(int sock, unsigned int pkt_num)\n{\n  struct msghdr msg;\n  struct iovec iov;\n  struct sockaddr_in host_address;\n  char buffer[2048];\n  char control[1024];\n  int got;\n\n  /* recvmsg header structure */\n  make_address(0, 0, &host_address);\n  iov.iov_base = buffer;\n  iov.iov_len = 2048;\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_name = &host_address;\n  msg.msg_namelen = sizeof(struct sockaddr_in);\n  msg.msg_control = control;\n  msg.msg_controllen = 1024;\n\n  /* block for message */\n  got = recvmsg(sock, &msg, 0);\n  TEST(got >= 0);\n\n  printf(\"Packet %d - %d bytes\\n\", pkt_num, got);\n\n  /* echo back */\n  msg.msg_controllen = 0;\n  iov.iov_len = got;\n  TRY(sendmsg(sock, &msg, 0));\n\n  /* retrieve TX timestamp */\n  msg.msg_control = control;\n  iov.iov_len = 2048;\n  do {\n    msg.msg_controllen = 1024;\n    got = recvmsg(sock, &msg, MSG_ERRQUEUE);\n  } while (got < 0 && errno == EAGAIN);\n  TEST(got >= 0);\n\n  handle_time(&msg);\n  return;\n};\n\n\nint main(int argc, char** argv)\n{\n  struct configuration cfg;\n  int sock;\n  unsigned int pkt_num = 0;\n\n  parse_options(argc, argv, &cfg);\n\n  /* Initialise */\n  sock = add_socket(&cfg);\n  do_mcast(&cfg, sock);\n  do_ioctl(&cfg, sock);\n  do_ts_sockopt(&cfg, sock);\n\n  /* Run until we've got enough packets, or an error occurs */\n  while( (pkt_num++ < cfg.cfg_max_packets) || (cfg.cfg_max_packets == 0) )\n    do_echo(sock, pkt_num);\n\n  close(sock);\n  return 0;\n}\n",
			"file": "tx_timestamping.c",
			"file_size": 14501,
			"file_write_time": 130984747760000000,
			"settings":
			{
				"buffer_size": 14502,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 288.0,
		"last_filter": "github ",
		"selected_items":
		[
			[
				"github ",
				"GitHub: Public Gist from Selection"
			],
			[
				"github",
				"GitHub: Update Gist"
			],
			[
				"package control ins",
				"Package Control: Install Package"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"github",
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Project/LatencyHunter/LatencyHunter"
	],
	"file_history":
	[
		"/C/log/peopleinmarket.txt",
		"/C/XING/SublimeText3/Data/Packages/Default/Preferences.sublime-settings",
		"/C/XING/SublimeText3/Data/Packages/User/Preferences.sublime-settings",
		"/Z/sync/gudaiwenxian/佛藏/大藏经/论藏/论疏部/瑜伽师地论略纂.txt",
		"/C/Project/TestSuite/Current/data_tool/run_all_tests.py",
		"/C/Project/LatencyHunter/LatencyHunter/sender.c",
		"/C/Project/LatencyHunter/LatencyHunter/receiver.c",
		"/C/Project/LatencyHunter/LatencyHunter/sock_common.c",
		"/C/Project/LatencyHunter/LatencyHunter/sock_common.h",
		"/C/Project/LatencyHunter/LatencyHunter/headers.h",
		"/C/Project/LatencyHunter/LatencyHunter/main.c",
		"/C/Project/LatencyHunter/LatencyHunter/Constants.h",
		"/C/Project/LatencyHunter/LatencyHunter/DEBUG.h",
		"/C/Users/XingC/Downloads/openonload-201509-u1/openonload-201509-u1/src/tests/ef_vi/efsink.c",
		"/C/Users/XingC/Downloads/openonload-201509-u1/openonload-201509-u1/src/tests/ef_vi/eftap.c",
		"/C/Users/XingC/Downloads/launch (8).jnlp",
		"/Z/Code/timestamp/myts.c",
		"/Z/Code/timestamp/sender.c",
		"/Z/sync/tmp/杂阿含经-刘宋-求那跋陀罗(3).txt",
		"/Z/sync/tmp/杂阿含经-刘宋-求那跋陀罗(2).txt",
		"/Z/sync/tmp/杂阿含经-刘宋-求那跋陀罗(1).txt",
		"/Z/sync/tmp/增一阿含经(2).txt",
		"/Z/sync/tmp/增一阿含经(1).txt",
		"/Z/sync/tmp/增一阿含经.txt",
		"/Z/sync/tmp/杂阿含经-刘宋-求那跋陀罗.txt",
		"/Z/Code/timestamp/DEBUG.h",
		"/Z/Code/timestamp/receiver.c",
		"/C/tmp/大般若波罗蜜多经(2).txt",
		"/C/tmp/大般若波罗蜜多经(1).txt",
		"/C/tmp/大般若波罗蜜多经(4).txt",
		"/C/tmp/大般若波罗蜜多经(3).txt",
		"/C/tmp/大般若波罗蜜多经(5).txt",
		"/C/tmp/大般若波罗蜜多经(6).txt",
		"/C/tmp/大般若波罗蜜多经(7).txt",
		"/C/tmp/大般若波罗蜜多经(8).txt",
		"/C/tmp/大般若波罗蜜多经(9).txt",
		"/C/tmp/大般若波罗蜜多经(10).txt",
		"/C/tmp/大般若波罗蜜多经(11).txt",
		"/C/tmp/大般若波罗蜜多经(12).txt",
		"/C/tmp/大般若波罗蜜多经(13).txt",
		"/C/tmp/大般若波罗蜜多经(14).txt",
		"/C/tmp/大般若波罗蜜多经(15).txt",
		"/C/tmp/大般若波罗蜜多经(16).txt",
		"/C/tmp/大般若波罗蜜多经(17).txt",
		"/C/tmp/大般若波罗蜜多经(18).txt",
		"/C/tmp/大般若波罗蜜多经(19).txt",
		"/C/tmp/大般若波罗蜜多经(20).txt",
		"/C/tmp/大般若波罗蜜多经(22).txt",
		"/C/tmp/大般若波罗蜜多经(21).txt",
		"/C/tmp/大般若波罗蜜多经(23).txt",
		"/C/tmp/大般若波罗蜜多经(24).txt",
		"/C/tmp/大般若波罗蜜多经(25).txt",
		"/C/tmp/大般若波罗蜜多经(26).txt",
		"/C/tmp/大般若波罗蜜多经(27).txt",
		"/C/tmp/大般若波罗蜜多经(28).txt",
		"/C/tmp/大般若波罗蜜多经(29).txt",
		"/C/tmp/大般若波罗蜜多经(30).txt",
		"/Z/client/Code/sockperf_bundle_test.sh",
		"/C/tmp/total.txt",
		"/C/tmp/大般若波罗蜜多经(26)",
		"/C/tmp/大般若波罗蜜多经(27)",
		"/C/tmp/大般若波罗蜜多经卷(27)",
		"/C/tmp/大般若波罗蜜多经(28)",
		"/C/tmp/大般若波罗蜜多经(29)",
		"/C/tmp/大般若波罗蜜多经(30)",
		"/Z/Code/Test/ts_google.c"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"ip_multicast_loop",
			"TX_TIMESTAMPING",
			"UDP",
			"enabled",
			"len",
			"next",
			"val",
			"device",
			"req",
			"杂阿含经-刘宋-求那跋陀罗",
			"第二十五",
			"大般若波罗蜜多经",
			"三十三",
			"十七",
			"卷第",
			"大般若波罗蜜多经",
			"卷第五百",
			"卷第五百三十九",
			"卷第五百八十",
			"卷第三百一",
			"printf(",
			"printf",
			"printf("
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"增一阿含经",
			"杂阿含经-刘宋-求那跋陀罗",
			"DEBUG("
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "sender.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6776,
						"regions":
						{
						},
						"selection":
						[
							[
								2442,
								2442
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 405.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "tx_timestamping.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14502,
						"regions":
						{
						},
						"selection":
						[
							[
								7721,
								7725
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3111.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "LatencyHunter.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 185.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
